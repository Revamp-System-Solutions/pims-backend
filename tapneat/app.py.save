import json
from flask import Flask, request, render_template
from flask_socketio import SocketIO, send, emit
from collections import namedtuple
from .model.model import *
from datetime import datetime, timedelta
import dateparser
from .model.schema import *

app = Flask(__name__)
app.config['SECRET_KEY'] = 'mysecret'
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:password@localhost/tapneat'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
socketio = SocketIO(app)

@socketio.on('connect')
def handleConnect():
	for trans in OrderTransaction.query.join(OrderTransaction.orderstat).filter_by(osId=1).all():
		result = OrderTransactionSchema.dump(trans).data
		emit('new orders', result, broadcast=False)
		
	for pd in promo_discount.query.all():
	 	pdresult = PromoDiscountSchema.dump(pd).data
	 	emit('get promo', pdresult, broadcast=False)


	for pt in PromoDiscountType.query.all():
	 	ptresult = PromoDiscountSchema.dump(pt).data
	 	emit('get promotype', ptresult, broadcast=False)

	for mitem in MenuItem.query.all():
		mresult = MenuItemSchema.dump(mitem).data
		#print(mresult['itemImage'])
		emit('get menu', mresult, broadcast=False)

	for sr in Specreq.query.all():
		sresult = SpecreqSchema.dump(sr).data
		emit('get sr', sresult, broadcast=False)

	for rt in reqtype.query.all():
		rresult = RequestTypeSchema.dump(rt).data
		emit('get rt', rresult, broadcast=False)
		
	for mc in menu_category.query.all():
		menucat = MenuCategorySchema.dump(mc).data
		# print(str(menucat));
		emit('get menucat', menucat, broadcast=False)

	settings = GeneralSettings.query.first()
	numoftables = settings.numOfTables
	emit('get tablenum', {"numoftables": numoftables}, broadcast=False)

	for trans in OrderTransaction.query.filter_by(date_time_cleared=None).all():
		result = OrderTransactionSchema.dump(trans).data
		emit('all orders', result, broadcast=False)

@socketio.on('message')
def handleMessage(msg):
	print('Message: ' + msg)
	send( msg, broadcast=True)

"""
Start of Kitchen functions
"""
@socketio.on('clear')
def handleClear(clr):
	ti = OrderTransaction.query.filter_by(otId=clr['transId']).first()
	ti.ordStatId= 2;
	db.session.commit()



@socketio.on('flag')
def handleFlag(flg):
	print('Flagging dish item unavailable: ' + str(flg))
	mi = MenuItem.query.filter_by(itemId=flg['itemId']).first()
	mi.itemStatusId = 2
	db.session.commit()
	

@socketio.on('unflag')
def handleFlag(unflg):
	print('Flagging dish item available: ' + str(unflg))
	mi = MenuItem.query.filter_by(itemId=unflg['itemId']).first()
	mi.itemStatusId = 1
	db.session.commit()
	


@socketio.on('order')
def handleOrder(ordr):
	print("Recieved"+ str(ordr))
	same = False
	if ordr['otId'] != "":
		for x in OrderTransaction.query.all():
			if x.otId == ordr['otId']:
				print(str(x.otId))
				x.cost = x.cost + ordr['totalcost']
				for l in ordr['orderlist']:
					ol = OrderList()
					ol.order_transaction = x
					mi = MenuItem.query.filter_by(itemId=l['menu_item']).first()
					#mi = MenuItem.query.get(l['itemid'])
					ol.menu_item = mi
					ol.qty = l['qty']
					#sp = Specreq.query.filter_by(srId=l['specreq']).first()
					ol.special_request_id = l['specreq']
					ol.request_type_id = l['reqtype']
					db.session.add(ol)
					db.session.commit()
					same = True
				res = OrderTransactionSchema.dump(x)
				errors = res.errors
				order_json = res.data
				emit('new orders', order_json, broadcast=True)
				emit('all orders', order_json, broadcast=True)
				print('Order sent')
	else:
		if same == False:
			print('I was here')
			trans = OrderTransaction()
			dt_sent = dateparser.parse(ordr['datesent'])
			trans.date_time_sent = dt_sent
			trans.ordQtId = ordr ['orderqueue']
			trans.ordtId = ordr ['ordertype']
			trans.number_of_guests = ordr['numofguest']
			trans.table_number = ordr['tablenum']
			trans.ctId = ordr ['custype']
			trans.ordStatId = ordr ['orderstat']
			trans.pId = ordr ['promo']
			trans.settingsId = ordr ['settings']
			trans.cost = ordr['totalcost']
			trans.uId = ordr['userid']
			for l in ordr['orderlist']:
				print(int(l['specreq']))
				ol = OrderList()
				ol.order_transaction = trans
				mi = MenuItem.query.filter_by(itemId=l['menu_item']).first()
				#mi = MenuItem.query.get(l['itemid'])
				ol.menu_item = mi
				ol.qty = l['qty']
				#sp = Specreq.query.filter_by(srId=l['specreq']).first()
				ol.special_request_id = int(l['specreq'])
				ol.request_type_id = int(l['reqtype'])
				db.session.add(ol)

			db.session.add(trans)
			db.session.commit()
			res = OrderTransactionSchema.dump(trans)
			errors = res.errors
			order_json = res.data
			emit('new orders', order_json, broadcast=True)
			emit('all orders', order_json, broadcast=True)
	# emit('order accepted', order_json, broadcast=True)

"""
End of kitchen function
"""
"""
login without accesslvl
"""
@socketio.on('login')
def handleLogin(details):
	access = False
	print("User" + str(details))
	#if details['username'] != "":
	#	usr = Users.query.filter_by(username = details['username']).first()
	#	if usr.username != None:
	#		if usr.userpass == details['password']:
				access = True

	emit('grant access', {'grantaccess': access}) 
"""
end of login
"""

"""
cashier
"""
@socketio.on('confirm')
def handleClear(cnfrm):
	print(str(cnfrm))
	ti = OrderTransaction.query.filter_by(otId=cnfrm['transId']).first()
	dt_clear = dateparser.parse(cnfrm['dateclear'])
	ti.date_time_cleared = dt_clear
	db.session.commit()
"""
end
"""
"""
Mobile
"""
@socketio.on('reqbill')
def handleRequest(req):
	print(str(req))
	emit('billrequest', req, broadcast=True)

@socketio.on('cancel')
def handleCancel(cncl):
	print(str(cncl))
	ti = OrderTransaction.query.filter_by(otId=cncl['otid']).first()
	dt_clear = dateparser.parse(cncl['dateclear'])
	ti.date_time_cleared = dt_clear
	ti.ordStatId= 3;
	db.session.commit()
	emit('cancelorders', cncl, broadcasat=True)

@socketio.on('cancelone')
def handleCancelOne(cnclone):
	print("hey"+ str(cnclone))
	ol = OrderList.query.filter_by(olId=cnclone['olId']).first()
	db.session.delete(ol)
	db.session.commit()
	
"""
End
"""

